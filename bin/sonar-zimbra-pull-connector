#!/usr/bin/env ruby

require 'rubygems'
require 'mysql'
require 'optparse'
require 'time'

require File.join(File.dirname(__FILE__), '..', 'lib', 'sonar-zimbra-pull-connector' )

OPTIONS = {
  :host => "localhost",
  :username => "root",
  :port => "7307",
  :password => "",
  :socket => "/opt/zimbra/db/mysql.sock",
  :min_date => nil,
  :exclude => "",
  :include => "",
  :target_dir => nil,
  :headers_only => 'n'
}

ARGV.options do |opts|

  script_name = File.basename( $0 )
  opts.banner = "Usage: #{script_name} [ -h <host> ] [ -u <username> ] [ -w <password> ] [ -p <port> ] [ -s <socket> ] [ -t <min date>] [ -x <email addresses to exclude>] [ -i <email addresses to include>] [ -d <target directory>]"
  opts.banner += "\n\nIf you do not specify -i or -x, it will attempt to retrieve emails for all accounts"
  opts.separator ""

  opts.on("-h", "--host=name", String,
          "Hostname of the zimbra db",
          "Default: #{OPTIONS[:host]}") { |h| OPTIONS[:host] = h }
  opts.on("-u", "--username=name", String,
          "Username for the zimbra db",
          "Default: #{OPTIONS[:username]}") { |h| OPTIONS[:username] = h }
  opts.on("-p", "--port=number", String,
          "Port for the zimbra db connection",
          "Default: #{OPTIONS[:port]}") { |h| OPTIONS[:port] = h }
  opts.on("-w", "--password=pwd", String,
          "Password for the zimbra db",
          "Default: #{OPTIONS[:password]}") { |h| OPTIONS[:password] = h }
  opts.on("-s", "--socket=path", String,
          "Path to the MySQL socket",
          "Default: #{OPTIONS[:socket]}") { |h| OPTIONS[:socket] = h }
  opts.on("-t", "--min-date=date", String,
          "Only get emails after this date",
          "Default: #{OPTIONS[:min_date].to_s}") { |h| OPTIONS[:min_date] = h }
  opts.on("-x", "--exclude=comma_delimited_email_addresses", String,
          "Comma-delimited list of email addresses to exclude",
          "Default: #{OPTIONS[:exclude]}") { |h| OPTIONS[:exclude] = h }
  opts.on("-i", "--include=comma_delimited_email_addresses", String,
          "Comma-delimited list of email addresses to include",
          "Default: #{OPTIONS[:include]}") { |h| OPTIONS[:include] = h }
	  
  opts.on("-d", "--target-dir=path", String,
          "Path to an output directory. If given, all matching rfc822 files will be copied to this directory.",
	  "If not given, the filenames of matching rfc822 files will be output to STDOUT.",
          "Default: #{OPTIONS[:target_dir]}") { |h| OPTIONS[:include] = h }
  opts.on("-o", "--headers-only=<y|n>", String,
          "Ignored unless -d|--target-dir is given.",
	  "If y, all body content and subject lines will be stripped from rfc822 files in the target directory.",
	  "If n, rfc822 files will be copied to the target directory as-is.",
          "Default: #{OPTIONS[:headers_only]}") { |h| OPTIONS[:headers_only] = h.downcase unless h.blank? }

  opts.parse!
end

def process_mail( mail, target_dir, headers_only )
  if target_dir.blank?
    STDOUT << mail['absolute_path'] << "\n" }
  else
    if headers_only
      content = Zimbra::Mail.headers( mail['absolute_path'] )
      target_path = File.join(target_dir, mail['relative_path'])
      log "mail #{mail['relative_path']} headers are #{content.size} bytes long, writing to #{target_path}"
      File.open( target_path, 'w' ){ |f| f.write(content) }
    else
      # log "copying #{mail['absolute_path']} to #{target_dir}"
      FileUtils.cp( mail['absolute_path'], target_dir, :preserve=>true, :verbose=>true )
    end
  end
end

def sync_mails( db, user, volumes, min_date = nil, target_dir, headers_only)
  mailbox_name = Zimbra::Users.mailbox_name( user['id'] )
  
  begin
    folders = Zimbra::Folders.get_folders( db, mailbox_name )
    
    log "got #{folders.length} folders to look in" 
  
    mails = Zimbra::Folders.get_mails_from_folders( db, mailbox_name, folders, volumes, min_date )
    log "got #{mails.length} mails for #{user['comment']}"
    
    mails.each{ |mail| 
      process_mail( mail, target_dir, headers_only )
    }
    
  rescue
    log "couldn't get mails for user #{user['id']} - #{user['comment']}"
    log "error was #{$!.inspect}"
  end
  
end

  
def log(s)
  STDERR << s << "\n"
end


######################################
# ACTUAL PROCESS STARTS HERE!
######################################

begin
  dbc = Zimbra::MySqlHelper.db_connection( OPTIONS )
  
  include_addresses = OPTIONS[:include].split(",")
  exclude_addresses = OPTIONS[:exclude].split(",")
  
  volumes = Zimbra::ZDB.get_volumes( dbc )
  users = Zimbra::ZDB.get_users(dbc, include_addresses, exclude_addresses )
  
  min_date = nil
  min_date_log = ""
  unless OPTIONS[:min_date].to_s.empty?
    begin
      min_date = Time.parse( OPTIONS[:min_date] )
      min_date_log = " since #{min_date.to_s}"
    rescue
      raise "INVALID DATE - couldn't parse '#{OPTIONS[:min_date]}'"
    end
  end
  
  log "got #{users.length} users"
  
  users.each do |user|
    log "extracting mails for #{user['comment']} #{min_date_log} "
    sync_mails( dbc, user, volumes, min_date, OPTIONS[:target_dir], OPTIONS[:headers_only] )
    log ""
  end
    
rescue Mysql::Error => e
  puts "Error code: #{e.errno}"
  puts "Error message: #{e.error}"
  puts "Error SQLSTATE: #{e.sqlstate}" if e.respond_to?("sqlstate")
ensure
  # must always ensure that we close the db connection
  dbc.close() if dbc
end


