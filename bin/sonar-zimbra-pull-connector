#!/usr/bin/env ruby

require 'rubygems'
require 'mysql'
require 'optparse'
require 'time'

require 'sonar-zimbra-pull-connector'

OPTIONS = {
  :host => "localhost",
  :username => "root",
  :port => "7307",
  :password => "",
  :socket => "/opt/zimbra/db/mysql.sock",
  :min_date => nil,
  :exclude => "",
  :include => ""
}



ARGV.options do |opts|

  script_name = File.basename( $0 )
  opts.banner = "Usage: #{script_name} [ -h <host> ] [ -u <username> ] [ -w <password> ] [ -p <port> ] [ -s <socket> ] [ -t <min date>] [ -x <email addresses to exclude>] [ -i <email addresses to include>]"
  opts.banner += "\n\nIf you do not specify -i or -x, it will attempt to retrieve emails for all accounts"
  opts.separator ""

  opts.on("-h", "--host=name", String,
          "Hostname of the zimbra db",
          "Default: #{OPTIONS[:host]}") { |h| OPTIONS[:host] = h }
  opts.on("-u", "--username=name", String,
          "Username for the zimbra db",
          "Default: #{OPTIONS[:username]}") { |h| OPTIONS[:username] = h }
  opts.on("-p", "--port=number", String,
          "Port for the zimbra db connection",
          "Default: #{OPTIONS[:port]}") { |h| OPTIONS[:port] = h }
  opts.on("-w", "--password=pwd", String,
          "Password for the zimbra db",
          "Default: #{OPTIONS[:password]}") { |h| OPTIONS[:password] = h }
  opts.on("-s", "--socket=path", String,
          "Path to the MySQL socket",
          "Default: #{OPTIONS[:socket]}") { |h| OPTIONS[:socket] = h }
  opts.on("-t", "--min-date=date", String,
          "Only get emails after this date",
          "Default: #{OPTIONS[:min_date].to_s}") { |h| OPTIONS[:min_date] = h }
  opts.on("-x", "--exclude=comma_delimited_email_addresses", String,
          "Comma-delimited list of email addresses to exclude",
          "Default: #{OPTIONS[:exclude]}") { |h| OPTIONS[:exclude] = h }
  opts.on("-i", "--include=comma_delimited_email_addresses", String,
          "Comma-delimited list of email addresses to include",
          "Default: #{OPTIONS[:include]}") { |h| OPTIONS[:include] = h }
  opts.parse!
end






def sync_mails( db, user, volumes, min_date = nil)
  mailbox_name = "mboxgroup#{user['id']}"
  
  begin
    folders = Zimbra::Folders.get_folders( db, mailbox_name )
    
    log "got #{folders.length} folders to look in" 
  
    mails = get_mails_from_folders( db, mailbox_name, folders, volumes, min_date )
    log "got #{mails.length} mails for #{user['comment']}"
    
    mails.each{ |mail| STDOUT << mail['absolute_path'] << "\n" }
    
  rescue
    log "couldn't get mails for user #{user['id']} - #{user['comment']}"
    log "error was #{$!.inspect}"
  end
  
end

  
def log(s)
  STDERR << s << "\n"
end


######################################
# ACTUAL PROCESS STARTS HERE!
######################################

begin
  dbc = Zimbra::MySqlHelper.db_connection( OPTIONS )
  
  include_addresses = OPTIONS[:include].split(",")
  exclude_addresses = OPTIONS[:exclude].split(",")
  
  volumes = Zimbra.get_volumes( dbc )
  users = Zimbra.get_users(dbc, include_addresses, exclude_addresses )
  
  min_date = nil
  min_date_log = ""
  unless OPTIONS[:min_date].to_s.empty?
    begin
      min_date = Time.parse( OPTIONS[:min_date] )
      min_date_log = " since #{min_date.to_s}"
    rescue
      raise "INVALID DATE - couldn't parse '#{OPTIONS[:min_date]}'"
    end
  end
  
  log "got #{users.length} users"
  
  users.each do |user|
    log "extracting mails for #{user['comment']} #{min_date_log} "
    sync_mails( dbh, user, volumes, min_date )
    log ""
  end
    
rescue Mysql::Error => e
  puts "Error code: #{e.errno}"
  puts "Error message: #{e.error}"
  puts "Error SQLSTATE: #{e.sqlstate}" if e.respond_to?("sqlstate")
ensure
  # must always ensure that we close the db connection
  dbh.close() if dbh
end


